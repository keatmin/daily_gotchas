"use strict";(self.webpackChunkgotchas=self.webpackChunkgotchas||[]).push([[1453],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return h}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=c(t),h=i,g=d["".concat(l,".").concat(h)]||d[h]||p[h]||o;return t?a.createElement(g,s(s({ref:n},u),{},{components:t})):a.createElement(g,s({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,s=new Array(o);s[0]=d;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var c=2;c<o;c++)s[c]=t[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7710:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return u},toc:function(){return p},default:function(){return h}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),s=["components"],r={slug:"async-mechanism",title:"Mechanism in async",authors:"keatmin",tags:["python","async"]},l=void 0,c={permalink:"/daily_gotchas/gotchas/async-mechanism",source:"@site/gotchas/2021-09-11-async.md",title:"Mechanism in async",description:"Usage of asyncio makes things easy when it works, but understanding what is happening and what is behind will help in designing better async app.",date:"2021-09-11T00:00:00.000Z",formattedDate:"September 11, 2021",tags:[{label:"python",permalink:"/daily_gotchas/gotchas/tags/python"},{label:"async",permalink:"/daily_gotchas/gotchas/tags/async"}],readingTime:4.365,truncated:!1,authors:[{name:"keatmin",title:"Data nerd",url:"https://github.com/keatmin",imageURL:"https://github.com/keatmin.png",key:"keatmin"}],nextItem:{title:"Managing Python Memory",permalink:"/daily_gotchas/gotchas/python-memory-management"}},u={authorsImageUrls:[void 0]},p=[{value:"await and async",id:"await-and-async",children:[]},{value:"queue in asyncio",id:"queue-in-asyncio",children:[]},{value:"what about <code>get_event_loop()</code>?",id:"what-about-get_event_loop",children:[]},{value:"Other functions",id:"other-functions",children:[{value:"<code>asyncio.create_task()</code>",id:"asynciocreate_task",children:[]}]},{value:"run as a service",id:"run-as-a-service",children:[]},{value:"consume exceptions",id:"consume-exceptions",children:[]},{value:"really concurrent",id:"really-concurrent",children:[{value:"<code>asyncio.gather()</code>",id:"asynciogather",children:[]}]},{value:"monitoring with events",id:"monitoring-with-events",children:[]},{value:"when shutting down",id:"when-shutting-down",children:[{value:"Add signal handling",id:"add-signal-handling",children:[]}]},{value:"good to know",id:"good-to-know",children:[]},{value:"useful resources",id:"useful-resources",children:[]}],d={toc:p};function h(e){var n=e.components,t=(0,i.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Usage of asyncio makes things easy when it works, but understanding what is happening and what is behind will help in designing better ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," app. "),(0,o.kt)("h2",{id:"await-and-async"},"await and async"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"await")," in an ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," function tells tells the event loop to suspend exec of ",(0,o.kt)("inlineCode",{parentName:"p"},"g()")," and do something else"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"\nasync def g():\n    r = await f()\n    return r\n")),(0,o.kt)("p",null,"Hence using ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," is creating a coroutine function. Calling a coroutine function requires ",(0,o.kt)("inlineCode",{parentName:"p"},"await")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"yield")," will give an async generator. Which can be used with ",(0,o.kt)("inlineCode",{parentName:"p"},"async for")),(0,o.kt)("h2",{id:"queue-in-asyncio"},"queue in asyncio"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"\nasync def produce(i: int, q: asyncio.Queue) -> None:\n    result = await f()\n    await q.put(result)\n\nasync def consume(i: int, q: asyncio.Queue) -> None:\n    tasks = await q.get()\n    try: \n        await do_task(tasks)\n    except exception as e:\n        print(e)\n        # return task to queue, use a counter to avoid running it infinitely\n        await q.put(i)\n    q.task_done()\n\nasync def main(n: int):\n    q = asyncio.Queue\n    # Fires up both producers and consumers\n    producers = [asyncio.create_task(produce(i, q)) for i in range(n)]\n    consumers = [asyncio.create_task(consume(i,q)) for i in range(n)] \n    await asyncio.gather(*producers) # Wait for producers to finish while both are running\n    await q.join() # This awaits for consumers implicitly and the rest of the tasks to be processed\n    for c in consumers:\n        c.cancel() # To cancel idle consumers when the queue is done\n\n")),(0,o.kt)("h2",{id:"what-about-get_event_loop"},"what about ",(0,o.kt)("inlineCode",{parentName:"h2"},"get_event_loop()"),"?"),(0,o.kt)("p",null,"Older examples use asyncio.get_event_loop(), mainly a pre Python 3.7 version. With Python 3.7, ",(0,o.kt)("inlineCode",{parentName:"p"},"asyncio.run(main())")," replaces the need of having to use ",(0,o.kt)("inlineCode",{parentName:"p"},"get_event_loop()")," which typically has a flow like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"loop = asyncio.get_event_loop(main())\ntry:\n    loop.run_until_complete(main())\nfinally:\n    loop.close()\n")),(0,o.kt)("p",null,"Unless there's a need to go into a lower level to fine tune control in the event loop, usually an asyncio.run() is sufficient.\nThe usage of ",(0,o.kt)("inlineCode",{parentName:"p"},"loop.is_running()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"loop.is_closed()")," is a good way to introspect loop and scheduling a callback. "),(0,o.kt)("h2",{id:"other-functions"},"Other functions"),(0,o.kt)("h3",{id:"asynciocreate_task"},(0,o.kt)("inlineCode",{parentName:"h3"},"asyncio.create_task()")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"create_task()")," introduced in Python 3.7 is used to schedule the execution of coroutine object.\nPrior to that it was ",(0,o.kt)("inlineCode",{parentName:"p"},"ensure_future()")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"async def do_task(a: list) -> list:\n    b = await task_c(a)\n    return b\n\nasync def main():\n    # For the sake of an example, this is done when in fact normally it can be done via asyncio.run(do_task(some_list)) or await do_task()\n    t = asyncio.create_task(do_task(some_list))\n    await t # Important to await t as asyncio.run() will run and will assume main is completed\n\nasyncio.run(main())\n")),(0,o.kt)("h2",{id:"run-as-a-service"},"run as a service"),(0,o.kt)("p",null,"Run run run\n",(0,o.kt)("inlineCode",{parentName:"p"},"run_forever()")),(0,o.kt)("h2",{id:"consume-exceptions"},"consume exceptions"),(0,o.kt)("p",null,"Asyncio is not super helpful when there's an exception and has to be retrieved"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"# Add a helpful wrapper\nasync def handle_exception(coro, loop):\n    try:\n        await coro\n    except Exception as e:\n        logging.error(e)\n        loop.stop()\n\n\nif __name__ == '__main__':\n    queue = asyncio.Queue()\n\n    loop = asyncio.get_event_loop()\n    loop.create_task(handle_exception(publish(queue),loop))\n    loop.create_task(handle_exception(consume(queue),loop))\n    try:\n        loop.run_forever()\n    finally:\n        logging.info(\"Clean up\")\n        loop.close()\n")),(0,o.kt)("h2",{id:"really-concurrent"},"really concurrent"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"async def consume(queue):\n    while True:\n        msg = await queue.get()\n        \n        asyncio.create_task(do_task(msg)) # Compared to 2 awaits, which is dependent from each other, doing these will make both independent concurrent tasks\n        asyncio.create_task(do_task_b(msg))\n")),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Sometimes you want some tasks to be still serial when tasks are dependent on each other"))),(0,o.kt)("h3",{id:"asynciogather"},(0,o.kt)("inlineCode",{parentName:"h3"},"asyncio.gather()")),(0,o.kt)("p",null,"This function just puts all the coroutines into one future returning only one future object. Essentially putting tasks into a list and waiting for it to be completed in the order it was created."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"results = await asyncio.gather(return_exceptions=True) #To return exceptions in the list\n\n# To retrieve\n[logging.error(result) for result in results if is_instance(result, Exception)]\n")),(0,o.kt)("p",null,"Adding callbacks to Future object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'\ndef cleanup(msg,fut):\n    logging.info(f"Acked {msg}")\n\nasync def handle_message(msg):\n    gathering = asyncio.gather(async_task_a(msg), async_task_b(msg)) # Add return_exceptions if want exceptions \n    callback = functools.partial(cleanup, msg)\n    gathering.add_done_callback(callback)\n')),(0,o.kt)("p",null,"If want to avoid callback and non-blocking it can just be awaited"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'async def cleanup(msg):\n    logging.info("done")\n    await async.sleep(0) # This is needed as logging.info does not return a coroutine\n\nasync def handle_message(msg):\n    await asyncio.gather(save(msg), restart_host(msg))\n    await cleanup(msg)\n')),(0,o.kt)("h2",{id:"monitoring-with-events"},"monitoring with events"),(0,o.kt)("p",null,"Using event to do specific actions, if not done, extend time (if there's a timeout)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'async def extend(msg, event):\n    while not event.is_set():\n        logging.info("Extend")\n        await asyncio.sleep(2)\n    else:\n        await cleanup(msg)\n\n\nasync def handle_message(msg):\n    event = asyncio.Event()\n    asyncio.create_task(extend(msg, event))\n    await asyncio.gather(do_task(msg), do_task_b(msg))\n    event.set() \n')),(0,o.kt)("p",null,"use ",(0,o.kt)("inlineCode",{parentName:"p"},"event.wait()")," when the task is being awaited and use it as blocking coro code"),(0,o.kt)("h2",{id:"when-shutting-down"},"when shutting down"),(0,o.kt)("h3",{id:"add-signal-handling"},"Add signal handling"),(0,o.kt)("p",null,"Refer to ",(0,o.kt)("a",{parentName:"p",href:"../knowledge/misc/signals.md"},"signals")," for list of signals"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'async def shutdown(signal, loop):\n    tasks = [t for t in asyncio.all_tasks() if t is not in asyncio.current_task()]\n    [task.cancel() for task in tasks]\n    \n    await asyncio.gather(*tasks) \n    loop.stop()\n\nif __name__ == "__main__":\n    signals = (signal.SIGHUP, signal.SIGTERM, signal.SIGINT)\n    for s in signals:\n        loop.add_signal_handler(s, lambda s=s: asyncio.create_task(shutdown(s,loop)))\n    queue = asyncio.Queue()\n    try: \n        await something()\n    except: asyncio.CancelledError: # This is neeed because when task is cancelling it will raise cancel error \n        logging.info("bla")\n')),(0,o.kt)("h2",{id:"good-to-know"},"good to know"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Coroutines are useless unless in event loop"),(0,o.kt)("li",{parentName:"ol"},"The default of asyncio is running in single thread and single CPU core"),(0,o.kt)("li",{parentName:"ol"},"async context manager is defined in ",(0,o.kt)("inlineCode",{parentName:"li"},".__aenter()__")," and ",(0,o.kt)("inlineCode",{parentName:"li"},".__a.exit()__")),(0,o.kt)("li",{parentName:"ol"},"If awaited task is CPU bound, running it in ",(0,o.kt)("inlineCode",{parentName:"li"},"loop.run_in_executor()")," will allow it to run in its own process"),(0,o.kt)("li",{parentName:"ol"},"Putting everything in async is useless if all of the functions have blocking calls."),(0,o.kt)("li",{parentName:"ol"},"Be sure to retrieve exceptions "),(0,o.kt)("li",{parentName:"ol"},"asychronous != concurrency, serial != blocking"),(0,o.kt)("li",{parentName:"ol"},"If using loop, cleanup using ",(0,o.kt)("inlineCode",{parentName:"li"},"loop.close()")),(0,o.kt)("li",{parentName:"ol"},"Iterating is blocking")),(0,o.kt)("h2",{id:"useful-resources"},"useful resources"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://realpython.com/async-io-python/"},"realpython"),"\n",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=1lJDZx6f6tY"},"ross' talks"),"\n",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=sW76-pRkZk8"},"more advanced ross'")))}h.isMDXComponent=!0}}]);